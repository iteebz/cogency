{
  "package": {
    "name": "cogency",
    "version": "0.9.0",
    "docstring": "Cogency - A framework for building intelligent agents."
  },
  "modules": {
    "agent": {
      "name": "agent",
      "docstring": "Main Agent class - cognitive orchestration with streaming, memory, and tool integration.",
      "classes": [
        {
          "name": "Agent",
          "docstring": "Cognitive agent with streaming execution, tool integration, memory and adaptive reasoning",
          "module": "cogency.agent",
          "methods": [
            {
              "name": "run",
              "docstring": "Run agent and return complete response as string (async)",
              "signature": "(self, query: str, user_id: str = 'default') -> str"
            },
            {
              "name": "stream",
              "docstring": "Stream agent execution",
              "signature": "(self, query: str, user_id: str = 'default') -> AsyncIterator[str]"
            },
            {
              "name": "traces",
              "docstring": "Get detailed execution traces from last run (debug mode only)",
              "signature": "(self) -> list[dict[str, typing.Any]]"
            }
          ],
          "init_signature": "(self, name: str = 'cogency', *, llm: Optional[cogency.services.llm.base.LLM] = None, embed: Optional[cogency.services.embed.base.Embed] = None, tools: Optional[List[cogency.tools.base.Tool]] = None, memory: Optional[cogency.memory.store.base.Store] = None, identity: Optional[str] = None, output_schema: Optional[Dict[str, Any]] = None, mode: Literal['fast', 'deep', 'adapt'] = 'adapt', depth: int = 10, notify: bool = True, debug: bool = False, formatter: Optional[cogency.notify.formatters.Formatter] = None, on_notify: Optional[<built-in function callable>] = None, robust: Union[bool, cogency.config.Robust] = True, observe: Union[bool, cogency.config.Observe] = False, persist: Union[bool, cogency.config.Persist] = False, mcp: bool = False) -> None"
        },
        {
          "name": "Embed",
          "docstring": "Base class for embedding providers",
          "module": "cogency.services.embed.base",
          "methods": [
            {
              "name": "embed",
              "docstring": "Embed text(s) - handles both single strings and lists",
              "signature": "(self, text: str | list[str], **kwargs) -> resilient_result.result.Result"
            },
            {
              "name": "embed_array",
              "docstring": "Embed texts and return as 2D numpy array",
              "signature": "(self, texts: list[str], **kwargs) -> resilient_result.result.Result"
            },
            {
              "name": "embed_text",
              "docstring": "Embed single text - convenience method for memory stores",
              "signature": "(self, text: str, **kwargs) -> resilient_result.result.Result"
            }
          ],
          "init_signature": "(self, api_key: str = None, **kwargs)"
        },
        {
          "name": "Formatter",
          "docstring": "Base formatter class - silent by default.",
          "module": "cogency.notify.formatters",
          "methods": [
            {
              "name": "format",
              "docstring": "Format notification. Returns None for silent mode (base class).",
              "signature": "(self, notification: cogency.notify.core.Notification) -> Optional[str]"
            }
          ],
          "init_signature": "(self, /, *args, **kwargs)"
        },
        {
          "name": "LLM",
          "docstring": "Base class for all LLM implementations in the cogency framework.\n\nAll LLM providers support:\n- Streaming execution for real-time output\n- Automatic key rotation for high-volume usage\n- Rate limiting via yield_interval parameter\n- Unified interface across providers\n- Dynamic model/parameter configuration",
          "module": "cogency.services.llm.base",
          "methods": [
            {
              "name": "next_key",
              "docstring": "Get next API key - rotates automatically on every call.",
              "signature": "(self) -> str"
            },
            {
              "name": "run",
              "docstring": "Generate a response from the LLM given a list of messages.\n\nArgs:\n    messages: List of message dictionaries with 'role' and 'content' keys\n    **kwargs: Additional parameters for the LLM call\n\nReturns:\n    Result containing string response from the LLM or error",
              "signature": "(self, messages: List[Dict[str, str]], **kwargs) -> resilient_result.result.Result"
            },
            {
              "name": "stream",
              "docstring": "Generate a streaming response from the LLM given a list of messages.\n\nArgs:\n    messages: List of message dictionaries with 'role' and 'content' keys\n    yield_interval: Minimum time between yields for rate limiting (seconds)\n    **kwargs: Additional parameters for the LLM call\n\nReturns:\n    AsyncIterator[str] for streaming response",
              "signature": "(self, messages: List[Dict[str, str]], **kwargs) -> AsyncIterator[str]"
            }
          ],
          "init_signature": "(self, provider_name: str, api_keys: Union[str, List[str]] = None, model: str = None, timeout: float = 15.0, temperature: float = 0.7, max_tokens: int = 16384, max_retries: int = 3, enable_cache: bool = True, **kwargs)"
        },
        {
          "name": "Notifier",
          "docstring": "v2 async notification orchestrator.",
          "module": "cogency.notify.notifier",
          "methods": [
            {
              "name": "emit",
              "docstring": "Legacy emit method - kept for backward compatibility.",
              "signature": "(self, notification_type: str, data: Dict[str, Any]) -> None"
            }
          ],
          "init_signature": "(self, formatter: cogency.notify.formatters.Formatter, on_notify: Optional[Callable] = None)"
        },
        {
          "name": "Observe",
          "docstring": "Observability/telemetry configuration for metrics collection.",
          "module": "cogency.config",
          "methods": [],
          "init_signature": "(self, metrics: bool = True, timing: bool = True, counters: bool = True, phases: Optional[List[str]] = None, export_format: str = 'prometheus', export_endpoint: Optional[str] = None) -> None"
        },
        {
          "name": "Persist",
          "docstring": "Configuration for state persistence.",
          "module": "cogency.config",
          "methods": [],
          "init_signature": "(self, enabled: bool = True, store: Optional[Any] = None) -> None"
        },
        {
          "name": "Robust",
          "docstring": "Comprehensive robustness configuration (retry, checkpointing, circuit breaker, rate limiting).",
          "module": "cogency.config",
          "methods": [],
          "init_signature": "(self, retry: bool = True, circuit: bool = True, rate_limit: bool = True, checkpoint: bool = True, attempts: int = 3, timeout: Optional[float] = None, backoff: str = 'exponential', backoff_delay: float = 0.1, backoff_factor: float = 2.0, backoff_max: float = 30.0, circuit_failures: int = 5, circuit_window: int = 300, rate_limit_rps: float = 10.0, rate_limit_burst: Optional[int] = None, ckpt_max_age: int = 1, ckpt_dir: Optional[str] = None) -> None"
        },
        {
          "name": "State",
          "docstring": "Clean dataclass state for agent execution.",
          "module": "cogency.state",
          "methods": [
            {
              "name": "add_action",
              "docstring": "Add action to reasoning history with new schema.",
              "signature": "(self, mode: str, thinking: str, planning: str, reflection: str, approach: str, tool_calls: List[cogency.types.tools.ToolCall]) -> None"
            },
            {
              "name": "add_message",
              "docstring": "Add message to conversation history.",
              "signature": "(self, role: str, content: str) -> None"
            },
            {
              "name": "add_tool_result",
              "docstring": "Add tool execution result to current action (schema-compliant).",
              "signature": "(self, name: str, args: dict, result: str, outcome: cogency.types.tools.ToolOutcome, iteration: Optional[int] = None) -> None"
            },
            {
              "name": "build_reasoning_context",
              "docstring": "Pure functional context generation using cognitive workspace.",
              "signature": "(self, mode: str, max_history: int = 3) -> str"
            },
            {
              "name": "get_conversation",
              "docstring": "Get clean conversation for LLM.",
              "signature": "(self) -> List[Dict[str, str]]"
            },
            {
              "name": "get_latest_results",
              "docstring": "Get tool results from most recent action as dicts.",
              "signature": "(self) -> List[Dict[str, Any]]"
            },
            {
              "name": "get_workspace_context",
              "docstring": "Build workspace context string for reasoning.",
              "signature": "(self) -> str"
            },
            {
              "name": "update_workspace",
              "docstring": "Update cognitive workspace fields with minimal bounds checking.",
              "signature": "(self, workspace_update: dict) -> None"
            }
          ],
          "init_signature": "(self, query: str, user_id: str = 'default', messages: List[Dict[str, str]] = <factory>, iteration: int = 0, depth: int = 10, mode: str = 'fast', stop_reason: Optional[str] = None, selected_tools: List[Any] = <factory>, tool_calls: List[Any] = <factory>, result: Any = None, actions: List[Dict[str, Any]] = <factory>, attempts: List[Any] = <factory>, objective: str = '', understanding: str = '', approach: str = '', discoveries: str = '', response: Optional[str] = None, respond_directly: bool = False, notify: bool = True, debug: bool = False, callback: Any = None, notifications: List[Dict[str, Any]] = <factory>) -> None"
        },
        {
          "name": "Store",
          "docstring": "Memory store with extensible backend implementations.",
          "module": "cogency.memory.store.base",
          "methods": [
            {
              "name": "create",
              "docstring": "CREATE - Standard artifact creation with storage delegation.",
              "signature": "(self, content: str, type: cogency.memory.types.MemoryType = <MemoryType.FACT: 'fact'>, tags: Optional[List[str]] = None, metadata: Optional[Dict[str, Any]] = None, **kwargs) -> resilient_result.result.Result"
            },
            {
              "name": "delete",
              "docstring": "DELETE - Unified deletion with assertive parameter validation.",
              "signature": "(self, artifact_id: uuid.UUID = None, tags: Optional[List[str]] = None, filters: Optional[Dict[str, Any]] = None, all: bool = False, **kwargs) -> resilient_result.result.Result"
            },
            {
              "name": "read",
              "docstring": "READ - Unified retrieval with assertive parameter validation.",
              "signature": "(self, query: str = None, id: uuid.UUID = None, search_type: cogency.memory.types.SearchType = <SearchType.AUTO: 'auto'>, limit: int = 10, threshold: float = 0.7, tags: Optional[List[str]] = None, type: Optional[cogency.memory.types.MemoryType] = None, filters: Optional[Dict[str, Any]] = None, **kwargs) -> resilient_result.result.Result"
            },
            {
              "name": "update",
              "docstring": "UPDATE - Standard update logic with storage delegation.",
              "signature": "(self, artifact_id: uuid.UUID, updates: Dict[str, Any]) -> resilient_result.result.Result"
            }
          ],
          "init_signature": "(self, embedder=None)"
        },
        {
          "name": "Tool",
          "docstring": "Base class for all tools in the cogency framework.\n\nStandardized tool interface requiring:\n- name, description, emoji: Tool identification\n- schema, examples, rules: LLM guidance (strings/lists in init)\n- run(): Core execution logic\n- format(): Display formatting for params and results",
          "module": "cogency.tools.base",
          "methods": [
            {
              "name": "execute",
              "docstring": "Execute tool with automatic validation and error handling - USE THIS, NOT run() directly.",
              "signature": "(self, **kwargs: Any) -> resilient_result.result.Result"
            },
            {
              "name": "format_agent",
              "docstring": "Format tool results for agent action history with auto-generation.",
              "signature": "(self, result_data: Dict[str, Any]) -> str"
            },
            {
              "name": "format_human",
              "docstring": "Format tool execution for human display with auto-generation.",
              "signature": "(self, params: Dict[str, Any], results: Optional[resilient_result.result.Result] = None) -> tuple[str, str]"
            },
            {
              "name": "run",
              "docstring": "Execute the tool with the given parameters.\n\nReturns:\n    Dict containing the tool's results or error information",
              "signature": "(self, **kwargs: Any) -> resilient_result.result.Result"
            }
          ],
          "init_signature": "(self, name: str, description: str, schema: str, emoji: str = 'ðŸ› ï¸', params: Optional[Type] = None, examples: Optional[List[str]] = None, rules: Optional[List[str]] = None)"
        }
      ],
      "functions": [
        {
          "name": "get_state",
          "docstring": "Get existing state or restore from persistence, creating new if needed.",
          "module": "cogency.persist.utils",
          "signature": "(user_id: str, query: str, depth: int, user_states: Dict[str, cogency.state.State], persistence=None) -> cogency.state.State"
        },
        {
          "name": "setup_config",
          "docstring": "",
          "module": "cogency.config",
          "signature": "(config_type, param, store=None)"
        },
        {
          "name": "setup_embed",
          "docstring": "Get embed provider class with automagical discovery.",
          "module": "cogency.services",
          "signature": "(provider: Optional[str] = None) -> Type[cogency.services.embed.base.Embed]"
        },
        {
          "name": "setup_formatter",
          "docstring": "Setup v2 notification formatter - zero ceremony with smart defaults.",
          "module": "cogency.notify.setup",
          "signature": "(notify: bool = True, debug: bool = False, style: str = None) -> cogency.notify.formatters.Formatter"
        },
        {
          "name": "setup_llm",
          "docstring": "Get LLM provider class or instance with automagical discovery.",
          "module": "cogency.services",
          "signature": "(provider: Union[str, cogency.services.llm.base.LLM, NoneType] = None) -> cogency.services.llm.base.LLM"
        },
        {
          "name": "setup_mcp",
          "docstring": "Setup MCP server if enabled and available.",
          "module": "cogency.mcp.server",
          "signature": "(agent, enabled: bool) -> Optional[cogency.mcp.server.MCPServer]"
        },
        {
          "name": "setup_memory",
          "docstring": "Setup memory backend with auto-detection.",
          "module": "cogency.memory.store.base",
          "signature": "(memory)"
        },
        {
          "name": "setup_phases",
          "docstring": "Zero ceremony phase creation.",
          "module": "cogency.phases",
          "signature": "(llm, tools, memory, identity, output_schema)"
        },
        {
          "name": "setup_tools",
          "docstring": "Setup tools with auto-discovery and recall integration.",
          "module": "cogency.tools.registry",
          "signature": "(tools, memory)"
        },
        {
          "name": "validate_query",
          "docstring": "Validate query input, return error message if invalid.",
          "module": "cogency.utils.validation",
          "signature": "(query: str) -> str | None"
        }
      ]
    },
    "config": {
      "name": "config",
      "docstring": "Configuration dataclasses - runtime limits, robustness, observability settings.",
      "classes": [
        {
          "name": "Observe",
          "docstring": "Observability/telemetry configuration for metrics collection.",
          "module": "cogency.config",
          "methods": [],
          "init_signature": "(self, metrics: bool = True, timing: bool = True, counters: bool = True, phases: Optional[List[str]] = None, export_format: str = 'prometheus', export_endpoint: Optional[str] = None) -> None"
        },
        {
          "name": "Persist",
          "docstring": "Configuration for state persistence.",
          "module": "cogency.config",
          "methods": [],
          "init_signature": "(self, enabled: bool = True, store: Optional[Any] = None) -> None"
        },
        {
          "name": "Robust",
          "docstring": "Comprehensive robustness configuration (retry, checkpointing, circuit breaker, rate limiting).",
          "module": "cogency.config",
          "methods": [],
          "init_signature": "(self, retry: bool = True, circuit: bool = True, rate_limit: bool = True, checkpoint: bool = True, attempts: int = 3, timeout: Optional[float] = None, backoff: str = 'exponential', backoff_delay: float = 0.1, backoff_factor: float = 2.0, backoff_max: float = 30.0, circuit_failures: int = 5, circuit_window: int = 300, rate_limit_rps: float = 10.0, rate_limit_burst: Optional[int] = None, ckpt_max_age: int = 1, ckpt_dir: Optional[str] = None) -> None"
        }
      ],
      "functions": [
        {
          "name": "setup_config",
          "docstring": "",
          "module": "cogency.config",
          "signature": "(config_type, param, store=None)"
        }
      ]
    },
    "tools": {
      "name": "tools",
      "docstring": "Tool registry - auto-discovery and initialization of all available tools.",
      "classes": [
        {
          "name": "CSV",
          "docstring": "Simple CSV operations - smart agent, dumb tool.",
          "module": "cogency.tools.csv",
          "methods": [
            {
              "name": "execute",
              "docstring": "Execute tool with automatic validation and error handling - USE THIS, NOT run() directly.",
              "signature": "(self, **kwargs: Any) -> resilient_result.result.Result"
            },
            {
              "name": "format_agent",
              "docstring": "Format CSV results for agent action history.",
              "signature": "(self, result_data: Dict[str, Any]) -> str"
            },
            {
              "name": "format_human",
              "docstring": "Format CSV execution for display.",
              "signature": "(self, params: Dict[str, Any], results: Optional[resilient_result.result.Result] = None) -> tuple[str, str]"
            },
            {
              "name": "run",
              "docstring": "Execute CSV operation.\n\nArgs:\n    operation: 'read', 'write', or 'append'\n    file_path: Path to CSV file\n    data: Data for write/append (list of dicts)",
              "signature": "(self, operation: str, file_path: str, data: Optional[List[Dict]] = None, **kwargs) -> Dict[str, Any]"
            }
          ],
          "init_signature": "(self)"
        },
        {
          "name": "Calculator",
          "docstring": "Base class for all tools in the cogency framework.\n\nStandardized tool interface requiring:\n- name, description, emoji: Tool identification\n- schema, examples, rules: LLM guidance (strings/lists in init)\n- run(): Core execution logic\n- format(): Display formatting for params and results",
          "module": "cogency.tools.calculator",
          "methods": [
            {
              "name": "execute",
              "docstring": "Execute tool with automatic validation and error handling - USE THIS, NOT run() directly.",
              "signature": "(self, **kwargs: Any) -> resilient_result.result.Result"
            },
            {
              "name": "format_agent",
              "docstring": "Format tool results for agent action history with auto-generation.",
              "signature": "(self, result_data: Dict[str, Any]) -> str"
            },
            {
              "name": "format_human",
              "docstring": "Format tool execution for human display with auto-generation.",
              "signature": "(self, params: Dict[str, Any], results: Optional[resilient_result.result.Result] = None) -> tuple[str, str]"
            },
            {
              "name": "run",
              "docstring": "Evaluate mathematical expressions - Wolfram Alpha style.",
              "signature": "(self, expression: str, **kwargs) -> Dict[str, Any]"
            }
          ],
          "init_signature": "(self)"
        },
        {
          "name": "Code",
          "docstring": "Execute Python and JavaScript code safely in isolated environment.",
          "module": "cogency.tools.code",
          "methods": [
            {
              "name": "execute",
              "docstring": "Execute tool with automatic validation and error handling - USE THIS, NOT run() directly.",
              "signature": "(self, **kwargs: Any) -> resilient_result.result.Result"
            },
            {
              "name": "format_agent",
              "docstring": "Format code execution results for agent action history.",
              "signature": "(self, result_data: Dict[str, Any]) -> str"
            },
            {
              "name": "format_human",
              "docstring": "Format code execution for display.",
              "signature": "(self, params: Dict[str, Any], results: Optional[resilient_result.result.Result] = None) -> tuple[str, str]"
            },
            {
              "name": "run",
              "docstring": "Execute code using dispatch pattern.\n\nArgs:\n    code: Source code to execute\n    language: Programming language (python, javascript/js)\n    timeout: Execution timeout in seconds (default: 30, max: 120)\n\nReturns:\n    Execution results including output, errors, and exit code",
              "signature": "(self, code: str, language: str = 'python', timeout: int = 30, **kwargs) -> Dict[str, Any]"
            }
          ],
          "init_signature": "(self)"
        },
        {
          "name": "Date",
          "docstring": "Date operations: parsing, formatting, arithmetic, weekday calculations.",
          "module": "cogency.tools.date",
          "methods": [
            {
              "name": "execute",
              "docstring": "Execute tool with automatic validation and error handling - USE THIS, NOT run() directly.",
              "signature": "(self, **kwargs: Any) -> resilient_result.result.Result"
            },
            {
              "name": "format_agent",
              "docstring": "Format date results for agent action history.",
              "signature": "(self, result_data: Dict[str, Any]) -> str"
            },
            {
              "name": "format_human",
              "docstring": "Format date execution for display.",
              "signature": "(self, params: Dict[str, Any], results: Optional[resilient_result.result.Result] = None) -> tuple[str, str]"
            },
            {
              "name": "run",
              "docstring": "Execute date operation.\nArgs:\n    operation: Operation to perform (parse, format, add, subtract, diff, is_weekend, weekday)\n    **kwargs: Operation-specific parameters\nReturns:\n    Operation result with date data",
              "signature": "(self, operation: str = 'parse', **kwargs) -> resilient_result.result.Result"
            }
          ],
          "init_signature": "(self)"
        },
        {
          "name": "Files",
          "docstring": "File operations within a safe base directory.",
          "module": "cogency.tools.files",
          "methods": [
            {
              "name": "execute",
              "docstring": "Execute tool with automatic validation and error handling - USE THIS, NOT run() directly.",
              "signature": "(self, **kwargs: Any) -> resilient_result.result.Result"
            },
            {
              "name": "format_agent",
              "docstring": "Format tool results for agent action history with auto-generation.",
              "signature": "(self, result_data: Dict[str, Any]) -> str"
            },
            {
              "name": "format_human",
              "docstring": "Format tool execution for human display with auto-generation.",
              "signature": "(self, params: Dict[str, Any], results: Optional[resilient_result.result.Result] = None) -> tuple[str, str]"
            },
            {
              "name": "run",
              "docstring": "Execute file operations.",
              "signature": "(self, action: str, filename: str = '', content: str = '', line: int = None, start: int = None, end: int = None) -> Dict[str, Any]"
            }
          ],
          "init_signature": "(self, base_dir: str = '.cogency/sandbox')"
        },
        {
          "name": "HTTP",
          "docstring": "HTTP client for API calls, webhooks, and web requests with full verb support.",
          "module": "cogency.tools.http",
          "methods": [
            {
              "name": "execute",
              "docstring": "Execute tool with automatic validation and error handling - USE THIS, NOT run() directly.",
              "signature": "(self, **kwargs: Any) -> resilient_result.result.Result"
            },
            {
              "name": "format_agent",
              "docstring": "Format tool results for agent action history with auto-generation.",
              "signature": "(self, result_data: Dict[str, Any]) -> str"
            },
            {
              "name": "format_human",
              "docstring": "Format tool execution for human display with auto-generation.",
              "signature": "(self, params: Dict[str, Any], results: Optional[resilient_result.result.Result] = None) -> tuple[str, str]"
            },
            {
              "name": "run",
              "docstring": "Execute HTTP request using dispatch pattern.\nArgs:\n    url: Target URL for the request\n    method: HTTP method (get, post, put, delete, patch)\n    headers: Optional HTTP headers dict\n    body: Optional request body as string\n    json_data: Optional JSON data (automatically sets content-type)\n    auth: Optional auth dict with 'type' and credentials\n    timeout: Request timeout in seconds (default: 30)\nReturns:\n    Response data including status, headers, and body",
              "signature": "(self, url: str, method: str = 'get', headers: Optional[Dict] = None, body: Optional[str] = None, json_data: Optional[Dict] = None, auth: Optional[Dict] = None, timeout: int = 30, **kwargs) -> Dict[str, Any]"
            }
          ],
          "init_signature": "(self)"
        },
        {
          "name": "Recall",
          "docstring": "Tool for retrieving content from agent memory.",
          "module": "cogency.tools.recall",
          "methods": [
            {
              "name": "execute",
              "docstring": "Execute tool with automatic validation and error handling - USE THIS, NOT run() directly.",
              "signature": "(self, **kwargs: Any) -> resilient_result.result.Result"
            },
            {
              "name": "format_agent",
              "docstring": "Format recall results for agent action history.",
              "signature": "(self, result_data: Dict[str, Any]) -> str"
            },
            {
              "name": "format_human",
              "docstring": "Format recall execution for display.",
              "signature": "(self, params: Dict[str, Any], results: Optional[resilient_result.result.Result] = None) -> tuple[str, str]"
            },
            {
              "name": "run",
              "docstring": "Retrieve content from memory.",
              "signature": "(self, query: str, limit: Optional[int] = None, tags: Optional[list] = None, **kwargs: Any) -> Dict[str, Any]"
            }
          ],
          "init_signature": "(self, memory: cogency.memory.store.base.Store)"
        },
        {
          "name": "SQL",
          "docstring": "Execute SQL queries across multiple database types with connection management.",
          "module": "cogency.tools.sql",
          "methods": [
            {
              "name": "execute",
              "docstring": "Execute tool with automatic validation and error handling - USE THIS, NOT run() directly.",
              "signature": "(self, **kwargs: Any) -> resilient_result.result.Result"
            },
            {
              "name": "format_agent",
              "docstring": "Format SQL results for agent action history.",
              "signature": "(self, result_data: Dict[str, Any]) -> str"
            },
            {
              "name": "format_human",
              "docstring": "Format SQL execution for display.",
              "signature": "(self, params: Dict[str, Any], results: Optional[resilient_result.result.Result] = None) -> tuple[str, str]"
            },
            {
              "name": "run",
              "docstring": "Execute SQL query using dispatch pattern.\nArgs:\n    query: SQL query to execute\n    connection: Database connection string (sqlite:///path, postgresql://..., mysql://...)\n    timeout: Query timeout in seconds (default: 30)\n    params: Optional query parameters for prepared statements\nReturns:\n    Query results including rows, columns, and metadata",
              "signature": "(self, query: str, connection: str, timeout: int = 30, params: Optional[List] = None, **kwargs) -> resilient_result.result.Result"
            }
          ],
          "init_signature": "(self)"
        },
        {
          "name": "Scrape",
          "docstring": "Extract clean text content from web pages using trafilatura.",
          "module": "cogency.tools.scrape",
          "methods": [
            {
              "name": "execute",
              "docstring": "Execute tool with automatic validation and error handling - USE THIS, NOT run() directly.",
              "signature": "(self, **kwargs: Any) -> resilient_result.result.Result"
            },
            {
              "name": "format_agent",
              "docstring": "Format scrape results for agent action history.",
              "signature": "(self, result_data: Dict[str, Any]) -> str"
            },
            {
              "name": "format_human",
              "docstring": "Format scrape execution for display.",
              "signature": "(self, params: Dict[str, Any], results: Optional[resilient_result.result.Result] = None) -> tuple[str, str]"
            },
            {
              "name": "run",
              "docstring": "Extract clean content from a web page.",
              "signature": "(self, url: str, favor_precision: bool = True, **kwargs) -> Dict[str, Any]"
            }
          ],
          "init_signature": "(self)"
        },
        {
          "name": "Search",
          "docstring": "Base class for all tools in the cogency framework.\n\nStandardized tool interface requiring:\n- name, description, emoji: Tool identification\n- schema, examples, rules: LLM guidance (strings/lists in init)\n- run(): Core execution logic\n- format(): Display formatting for params and results",
          "module": "cogency.tools.search",
          "methods": [
            {
              "name": "execute",
              "docstring": "Execute tool with automatic validation and error handling - USE THIS, NOT run() directly.",
              "signature": "(self, **kwargs: Any) -> resilient_result.result.Result"
            },
            {
              "name": "format_agent",
              "docstring": "Format search results for agent action history - show knowledge gained.",
              "signature": "(self, result_data: Dict[str, Any]) -> str"
            },
            {
              "name": "format_human",
              "docstring": "Format search execution for human display.",
              "signature": "(self, params: Dict[str, Any], results: Optional[resilient_result.result.Result] = None) -> tuple[str, str]"
            },
            {
              "name": "run",
              "docstring": "Execute the tool with the given parameters.\n\nReturns:\n    Dict containing the tool's results or error information",
              "signature": "(self, query: str, max_results: int = 5, **kwargs) -> Dict[str, Any]"
            }
          ],
          "init_signature": "(self)"
        },
        {
          "name": "Shell",
          "docstring": "Execute system commands safely with timeout and basic sandboxing.",
          "module": "cogency.tools.shell",
          "methods": [
            {
              "name": "execute",
              "docstring": "Execute tool with automatic validation and error handling - USE THIS, NOT run() directly.",
              "signature": "(self, **kwargs: Any) -> resilient_result.result.Result"
            },
            {
              "name": "format_agent",
              "docstring": "Format shell execution results for agent action history.",
              "signature": "(self, result_data: Dict[str, Any]) -> str"
            },
            {
              "name": "format_human",
              "docstring": "Format shell execution for display.",
              "signature": "(self, params: Dict[str, Any], results: Optional[resilient_result.result.Result] = None) -> tuple[str, str]"
            },
            {
              "name": "run",
              "docstring": "Execute shell command with safety checks.\n\nArgs:\n    command: Shell command to execute\n    timeout: Command timeout in seconds (default: 30, max: 300)\n    working_dir: Optional working directory (must be safe)\n    env: Optional environment variables to add\n\nReturns:\n    Command execution results including stdout, stderr, and exit code",
              "signature": "(self, command: str, timeout: int = 30, working_dir: Optional[str] = None, env: Optional[Dict[str, str]] = None, **kwargs) -> Dict[str, Any]"
            }
          ],
          "init_signature": "(self, default_working_dir: str = '.cogency/sandbox')"
        },
        {
          "name": "Time",
          "docstring": "Time operations: current time, timezone conversion, relative time.",
          "module": "cogency.tools.time",
          "methods": [
            {
              "name": "execute",
              "docstring": "Execute tool with automatic validation and error handling - USE THIS, NOT run() directly.",
              "signature": "(self, **kwargs: Any) -> resilient_result.result.Result"
            },
            {
              "name": "format_agent",
              "docstring": "Format time results for agent action history.",
              "signature": "(self, result_data: Dict[str, Any]) -> str"
            },
            {
              "name": "format_human",
              "docstring": "Format time execution for display.",
              "signature": "(self, params: dict[str, typing.Any], results: Optional[resilient_result.result.Result] = None) -> tuple[str, str]"
            },
            {
              "name": "run",
              "docstring": "Execute time operation.\n\nArgs:\n    operation: Operation to perform (now, relative, convert_timezone)\n    **kwargs: Operation-specific parameters\n\nReturns:\n    Operation result with time data",
              "signature": "(self, operation: str = 'now', **kwargs) -> resilient_result.result.Result"
            }
          ],
          "init_signature": "(self)"
        },
        {
          "name": "Tool",
          "docstring": "Base class for all tools in the cogency framework.\n\nStandardized tool interface requiring:\n- name, description, emoji: Tool identification\n- schema, examples, rules: LLM guidance (strings/lists in init)\n- run(): Core execution logic\n- format(): Display formatting for params and results",
          "module": "cogency.tools.base",
          "methods": [
            {
              "name": "execute",
              "docstring": "Execute tool with automatic validation and error handling - USE THIS, NOT run() directly.",
              "signature": "(self, **kwargs: Any) -> resilient_result.result.Result"
            },
            {
              "name": "format_agent",
              "docstring": "Format tool results for agent action history with auto-generation.",
              "signature": "(self, result_data: Dict[str, Any]) -> str"
            },
            {
              "name": "format_human",
              "docstring": "Format tool execution for human display with auto-generation.",
              "signature": "(self, params: Dict[str, Any], results: Optional[resilient_result.result.Result] = None) -> tuple[str, str]"
            },
            {
              "name": "run",
              "docstring": "Execute the tool with the given parameters.\n\nReturns:\n    Dict containing the tool's results or error information",
              "signature": "(self, **kwargs: Any) -> resilient_result.result.Result"
            }
          ],
          "init_signature": "(self, name: str, description: str, schema: str, emoji: str = 'ðŸ› ï¸', params: Optional[Type] = None, examples: Optional[List[str]] = None, rules: Optional[List[str]] = None)"
        },
        {
          "name": "Weather",
          "docstring": "Get current weather for any city using Open-Meteo (no API key required).",
          "module": "cogency.tools.weather",
          "methods": [
            {
              "name": "execute",
              "docstring": "Execute tool with automatic validation and error handling - USE THIS, NOT run() directly.",
              "signature": "(self, **kwargs: Any) -> resilient_result.result.Result"
            },
            {
              "name": "format_agent",
              "docstring": "Format tool results for agent action history with auto-generation.",
              "signature": "(self, result_data: Dict[str, Any]) -> str"
            },
            {
              "name": "format_human",
              "docstring": "Format tool execution for human display with auto-generation.",
              "signature": "(self, params: Dict[str, Any], results: Optional[resilient_result.result.Result] = None) -> tuple[str, str]"
            },
            {
              "name": "run",
              "docstring": "Get weather for a city.\n\nArgs:\n    city: City name (e.g., \"San Francisco\", \"London\", \"Tokyo\")\n\nReturns:\n    Weather data including temperature, conditions, humidity",
              "signature": "(self, city: str, **kwargs) -> resilient_result.result.Result"
            }
          ],
          "init_signature": "(self)"
        }
      ],
      "functions": [
        {
          "name": "build_registry",
          "docstring": "Build tool registry with optional details.",
          "module": "cogency.tools.registry",
          "signature": "(tools: List[cogency.tools.base.Tool], lite: bool = False) -> str"
        },
        {
          "name": "get_tools",
          "docstring": "Get all registered tool instances.",
          "module": "cogency.tools.registry",
          "signature": "(**kwargs) -> List[cogency.tools.base.Tool]"
        },
        {
          "name": "run_tools",
          "docstring": "Execute tools.",
          "module": "cogency.tools.executor",
          "signature": "(tool_calls: List[Tuple[str, Dict]], tools: List[cogency.tools.base.Tool], state, notifier=None) -> Dict[str, Any]"
        },
        {
          "name": "setup_tools",
          "docstring": "Setup tools with auto-discovery and recall integration.",
          "module": "cogency.tools.registry",
          "signature": "(tools, memory)"
        },
        {
          "name": "tool",
          "docstring": "Decorator to auto-register tools.",
          "module": "cogency.tools.registry",
          "signature": "(cls)"
        }
      ]
    },
    "memory": {
      "name": "memory",
      "docstring": "Memory primitives for Cogency agents.",
      "classes": [
        {
          "name": "Chroma",
          "docstring": "ChromaDB storage implementation.",
          "module": "cogency.memory.store.chroma",
          "methods": [
            {
              "name": "create",
              "docstring": "CREATE - Standard artifact creation with storage delegation.",
              "signature": "(self, content: str, type: cogency.memory.types.MemoryType = <MemoryType.FACT: 'fact'>, tags: Optional[List[str]] = None, metadata: Optional[Dict[str, Any]] = None, **kwargs) -> resilient_result.result.Result"
            },
            {
              "name": "delete",
              "docstring": "DELETE - Unified deletion with assertive parameter validation.",
              "signature": "(self, artifact_id: uuid.UUID = None, tags: Optional[List[str]] = None, filters: Optional[Dict[str, Any]] = None, all: bool = False, **kwargs) -> resilient_result.result.Result"
            },
            {
              "name": "get_stats",
              "docstring": "Get memory statistics.",
              "signature": "(self) -> Dict[str, Any]"
            },
            {
              "name": "read",
              "docstring": "READ - Unified retrieval with assertive parameter validation.",
              "signature": "(self, query: str = None, id: uuid.UUID = None, search_type: cogency.memory.types.SearchType = <SearchType.AUTO: 'auto'>, limit: int = 10, threshold: float = 0.7, tags: Optional[List[str]] = None, type: Optional[cogency.memory.types.MemoryType] = None, filters: Optional[Dict[str, Any]] = None, **kwargs) -> resilient_result.result.Result"
            },
            {
              "name": "update",
              "docstring": "UPDATE - Standard update logic with storage delegation.",
              "signature": "(self, artifact_id: uuid.UUID, updates: Dict[str, Any]) -> resilient_result.result.Result"
            }
          ],
          "init_signature": "(self, collection_name: str = 'memory_artifacts', persist_directory: Optional[str] = None, host: Optional[str] = None, port: Optional[int] = None, embedder=None)"
        },
        {
          "name": "Filesystem",
          "docstring": "Filesystem storage implementation.",
          "module": "cogency.memory.store.filesystem",
          "methods": [
            {
              "name": "create",
              "docstring": "CREATE - Standard artifact creation with storage delegation.",
              "signature": "(self, content: str, type: cogency.memory.types.MemoryType = <MemoryType.FACT: 'fact'>, tags: Optional[List[str]] = None, metadata: Optional[Dict[str, Any]] = None, **kwargs) -> resilient_result.result.Result"
            },
            {
              "name": "delete",
              "docstring": "DELETE - Unified deletion with assertive parameter validation.",
              "signature": "(self, artifact_id: uuid.UUID = None, tags: Optional[List[str]] = None, filters: Optional[Dict[str, Any]] = None, all: bool = False, **kwargs) -> resilient_result.result.Result"
            },
            {
              "name": "read",
              "docstring": "READ - Unified retrieval with assertive parameter validation.",
              "signature": "(self, query: str = None, id: uuid.UUID = None, search_type: cogency.memory.types.SearchType = <SearchType.AUTO: 'auto'>, limit: int = 10, threshold: float = 0.7, tags: Optional[List[str]] = None, type: Optional[cogency.memory.types.MemoryType] = None, filters: Optional[Dict[str, Any]] = None, **kwargs) -> resilient_result.result.Result"
            },
            {
              "name": "update",
              "docstring": "UPDATE - Standard update logic with storage delegation.",
              "signature": "(self, artifact_id: uuid.UUID, updates: Dict[str, Any]) -> resilient_result.result.Result"
            }
          ],
          "init_signature": "(self, memory_dir: str = '.cogency/memory', embedder=None)"
        },
        {
          "name": "Memory",
          "docstring": "A memory artifact with content and metadata.",
          "module": "cogency.memory.types",
          "methods": [
            {
              "name": "decay",
              "docstring": "Calculate decay based on recency and confidence.",
              "signature": "(self) -> float"
            },
            {
              "name": "to_dict",
              "docstring": "Convert Memory to dictionary for serialization.",
              "signature": "(self) -> Dict[str, Any]"
            }
          ],
          "init_signature": "(self, content: str, type: cogency.memory.types.MemoryType = <MemoryType.FACT: 'fact'>, tags: List[str] = <factory>, metadata: Dict[str, Any] = <factory>, id: uuid.UUID = <factory>, created_at: datetime.datetime = <factory>, relevance_score: float = 0.0, confidence: float = 1.0, access_count: int = 0, last_accessed: datetime.datetime = <factory>) -> None"
        },
        {
          "name": "MemoryType",
          "docstring": "Types of memory for different agent use cases.",
          "module": "cogency.memory.types",
          "methods": [],
          "init_signature": "(self, *args, **kwds)"
        },
        {
          "name": "PGVector",
          "docstring": "PGVector storage implementation.",
          "module": "cogency.memory.store.postgres",
          "methods": [
            {
              "name": "create",
              "docstring": "CREATE - Standard artifact creation with storage delegation.",
              "signature": "(self, content: str, type: cogency.memory.types.MemoryType = <MemoryType.FACT: 'fact'>, tags: Optional[List[str]] = None, metadata: Optional[Dict[str, Any]] = None, **kwargs) -> resilient_result.result.Result"
            },
            {
              "name": "delete",
              "docstring": "DELETE - Unified deletion with assertive parameter validation.",
              "signature": "(self, artifact_id: uuid.UUID = None, tags: Optional[List[str]] = None, filters: Optional[Dict[str, Any]] = None, all: bool = False, **kwargs) -> resilient_result.result.Result"
            },
            {
              "name": "get_stats",
              "docstring": "Get memory statistics.",
              "signature": "(self) -> resilient_result.result.Result[typing.Dict[str, typing.Any], Exception]"
            },
            {
              "name": "read",
              "docstring": "READ - Unified retrieval with assertive parameter validation.",
              "signature": "(self, query: str = None, id: uuid.UUID = None, search_type: cogency.memory.types.SearchType = <SearchType.AUTO: 'auto'>, limit: int = 10, threshold: float = 0.7, tags: Optional[List[str]] = None, type: Optional[cogency.memory.types.MemoryType] = None, filters: Optional[Dict[str, Any]] = None, **kwargs) -> resilient_result.result.Result"
            },
            {
              "name": "update",
              "docstring": "UPDATE - Standard update logic with storage delegation.",
              "signature": "(self, artifact_id: uuid.UUID, updates: Dict[str, Any]) -> resilient_result.result.Result"
            }
          ],
          "init_signature": "(self, connection_string: str, table_name: str = 'memory_artifacts', vector_dimensions: int = 1536, embedder=None)"
        },
        {
          "name": "Pinecone",
          "docstring": "Pinecone storage implementation.",
          "module": "cogency.memory.store.pinecone",
          "methods": [
            {
              "name": "create",
              "docstring": "CREATE - Standard artifact creation with storage delegation.",
              "signature": "(self, content: str, type: cogency.memory.types.MemoryType = <MemoryType.FACT: 'fact'>, tags: Optional[List[str]] = None, metadata: Optional[Dict[str, Any]] = None, **kwargs) -> resilient_result.result.Result"
            },
            {
              "name": "delete",
              "docstring": "DELETE - Unified deletion with assertive parameter validation.",
              "signature": "(self, artifact_id: uuid.UUID = None, tags: Optional[List[str]] = None, filters: Optional[Dict[str, Any]] = None, all: bool = False, **kwargs) -> resilient_result.result.Result"
            },
            {
              "name": "get_stats",
              "docstring": "Get memory statistics.",
              "signature": "(self) -> Dict[str, Any]"
            },
            {
              "name": "read",
              "docstring": "READ - Unified retrieval with assertive parameter validation.",
              "signature": "(self, query: str = None, id: uuid.UUID = None, search_type: cogency.memory.types.SearchType = <SearchType.AUTO: 'auto'>, limit: int = 10, threshold: float = 0.7, tags: Optional[List[str]] = None, type: Optional[cogency.memory.types.MemoryType] = None, filters: Optional[Dict[str, Any]] = None, **kwargs) -> resilient_result.result.Result"
            },
            {
              "name": "update",
              "docstring": "UPDATE - Standard update logic with storage delegation.",
              "signature": "(self, artifact_id: uuid.UUID, updates: Dict[str, Any]) -> resilient_result.result.Result"
            }
          ],
          "init_signature": "(self, api_key: str, index_name: str, environment: str = 'us-east-1-aws', dimension: int = 1536, embedder=None)"
        },
        {
          "name": "SearchType",
          "docstring": "Search methods for memory recall.",
          "module": "cogency.memory.types",
          "methods": [],
          "init_signature": "(self, *args, **kwds)"
        },
        {
          "name": "Store",
          "docstring": "Memory store with extensible backend implementations.",
          "module": "cogency.memory.store.base",
          "methods": [
            {
              "name": "create",
              "docstring": "CREATE - Standard artifact creation with storage delegation.",
              "signature": "(self, content: str, type: cogency.memory.types.MemoryType = <MemoryType.FACT: 'fact'>, tags: Optional[List[str]] = None, metadata: Optional[Dict[str, Any]] = None, **kwargs) -> resilient_result.result.Result"
            },
            {
              "name": "delete",
              "docstring": "DELETE - Unified deletion with assertive parameter validation.",
              "signature": "(self, artifact_id: uuid.UUID = None, tags: Optional[List[str]] = None, filters: Optional[Dict[str, Any]] = None, all: bool = False, **kwargs) -> resilient_result.result.Result"
            },
            {
              "name": "read",
              "docstring": "READ - Unified retrieval with assertive parameter validation.",
              "signature": "(self, query: str = None, id: uuid.UUID = None, search_type: cogency.memory.types.SearchType = <SearchType.AUTO: 'auto'>, limit: int = 10, threshold: float = 0.7, tags: Optional[List[str]] = None, type: Optional[cogency.memory.types.MemoryType] = None, filters: Optional[Dict[str, Any]] = None, **kwargs) -> resilient_result.result.Result"
            },
            {
              "name": "update",
              "docstring": "UPDATE - Standard update logic with storage delegation.",
              "signature": "(self, artifact_id: uuid.UUID, updates: Dict[str, Any]) -> resilient_result.result.Result"
            }
          ],
          "init_signature": "(self, embedder=None)"
        }
      ],
      "functions": [
        {
          "name": "search",
          "docstring": "Execute search across artifacts.",
          "module": "cogency.memory.search",
          "signature": "(query: str, artifacts: List[cogency.memory.types.Memory], search_type: cogency.memory.types.SearchType, threshold: float, embedder=None, embed: Optional[Callable[[uuid.UUID], Optional[List[float]]]] = None) -> List[cogency.memory.types.Memory]"
        },
        {
          "name": "setup_memory",
          "docstring": "Setup memory backend with auto-detection.",
          "module": "cogency.memory.store.base",
          "signature": "(memory)"
        }
      ]
    },
    "services": {
      "name": "services",
      "docstring": "Services - automagical discovery for LLM and embed stores.",
      "classes": [
        {
          "name": "Anthropic",
          "docstring": "Base class for all LLM implementations in the cogency framework.\n\nAll LLM providers support:\n- Streaming execution for real-time output\n- Automatic key rotation for high-volume usage\n- Rate limiting via yield_interval parameter\n- Unified interface across providers\n- Dynamic model/parameter configuration",
          "module": "cogency.services.llm.anthropic",
          "methods": [
            {
              "name": "next_key",
              "docstring": "Get next API key - rotates automatically on every call.",
              "signature": "(self) -> str"
            },
            {
              "name": "run",
              "docstring": "Generate a response from the LLM given a list of messages.\n\nArgs:\n    messages: List of message dictionaries with 'role' and 'content' keys\n    **kwargs: Additional parameters for the LLM call\n\nReturns:\n    Result containing string response from the LLM or error",
              "signature": "(self, messages: List[Dict[str, str]], **kwargs) -> resilient_result.result.Result"
            },
            {
              "name": "stream",
              "docstring": "Generate a streaming response from the LLM given a list of messages.\n\nArgs:\n    messages: List of message dictionaries with 'role' and 'content' keys\n    yield_interval: Minimum time between yields for rate limiting (seconds)\n    **kwargs: Additional parameters for the LLM call\n\nReturns:\n    AsyncIterator[str] for streaming response",
              "signature": "(self, messages: List[Dict[str, str]], **kwargs) -> AsyncIterator[str]"
            }
          ],
          "init_signature": "(self, **kwargs)"
        },
        {
          "name": "Embed",
          "docstring": "Base class for embedding providers",
          "module": "cogency.services.embed.base",
          "methods": [
            {
              "name": "embed",
              "docstring": "Embed text(s) - handles both single strings and lists",
              "signature": "(self, text: str | list[str], **kwargs) -> resilient_result.result.Result"
            },
            {
              "name": "embed_array",
              "docstring": "Embed texts and return as 2D numpy array",
              "signature": "(self, texts: list[str], **kwargs) -> resilient_result.result.Result"
            },
            {
              "name": "embed_text",
              "docstring": "Embed single text - convenience method for memory stores",
              "signature": "(self, text: str, **kwargs) -> resilient_result.result.Result"
            }
          ],
          "init_signature": "(self, api_key: str = None, **kwargs)"
        },
        {
          "name": "Gemini",
          "docstring": "Base class for all LLM implementations in the cogency framework.\n\nAll LLM providers support:\n- Streaming execution for real-time output\n- Automatic key rotation for high-volume usage\n- Rate limiting via yield_interval parameter\n- Unified interface across providers\n- Dynamic model/parameter configuration",
          "module": "cogency.services.llm.gemini",
          "methods": [
            {
              "name": "next_key",
              "docstring": "Get next API key - rotates automatically on every call.",
              "signature": "(self) -> str"
            },
            {
              "name": "run",
              "docstring": "Generate a response from the LLM given a list of messages.\n\nArgs:\n    messages: List of message dictionaries with 'role' and 'content' keys\n    **kwargs: Additional parameters for the LLM call\n\nReturns:\n    Result containing string response from the LLM or error",
              "signature": "(self, messages: List[Dict[str, str]], **kwargs) -> resilient_result.result.Result"
            },
            {
              "name": "stream",
              "docstring": "Generate a streaming response from the LLM given a list of messages.\n\nArgs:\n    messages: List of message dictionaries with 'role' and 'content' keys\n    yield_interval: Minimum time between yields for rate limiting (seconds)\n    **kwargs: Additional parameters for the LLM call\n\nReturns:\n    AsyncIterator[str] for streaming response",
              "signature": "(self, messages: List[Dict[str, str]], **kwargs) -> AsyncIterator[str]"
            }
          ],
          "init_signature": "(self, **kwargs)"
        },
        {
          "name": "LLM",
          "docstring": "Base class for all LLM implementations in the cogency framework.\n\nAll LLM providers support:\n- Streaming execution for real-time output\n- Automatic key rotation for high-volume usage\n- Rate limiting via yield_interval parameter\n- Unified interface across providers\n- Dynamic model/parameter configuration",
          "module": "cogency.services.llm.base",
          "methods": [
            {
              "name": "next_key",
              "docstring": "Get next API key - rotates automatically on every call.",
              "signature": "(self) -> str"
            },
            {
              "name": "run",
              "docstring": "Generate a response from the LLM given a list of messages.\n\nArgs:\n    messages: List of message dictionaries with 'role' and 'content' keys\n    **kwargs: Additional parameters for the LLM call\n\nReturns:\n    Result containing string response from the LLM or error",
              "signature": "(self, messages: List[Dict[str, str]], **kwargs) -> resilient_result.result.Result"
            },
            {
              "name": "stream",
              "docstring": "Generate a streaming response from the LLM given a list of messages.\n\nArgs:\n    messages: List of message dictionaries with 'role' and 'content' keys\n    yield_interval: Minimum time between yields for rate limiting (seconds)\n    **kwargs: Additional parameters for the LLM call\n\nReturns:\n    AsyncIterator[str] for streaming response",
              "signature": "(self, messages: List[Dict[str, str]], **kwargs) -> AsyncIterator[str]"
            }
          ],
          "init_signature": "(self, provider_name: str, api_keys: Union[str, List[str]] = None, model: str = None, timeout: float = 15.0, temperature: float = 0.7, max_tokens: int = 16384, max_retries: int = 3, enable_cache: bool = True, **kwargs)"
        },
        {
          "name": "LLMCache",
          "docstring": "Smart LLM response cache with TTL and size limits.",
          "module": "cogency.services.llm.cache",
          "methods": [
            {
              "name": "clear",
              "docstring": "Clear all cached entries.",
              "signature": "(self) -> None"
            },
            {
              "name": "get",
              "docstring": "Get cached response if available and valid.",
              "signature": "(self, messages: List[Dict[str, str]], **kwargs) -> Optional[str]"
            },
            {
              "name": "get_stats",
              "docstring": "Get cache performance statistics.",
              "signature": "(self) -> Dict[str, Any]"
            },
            {
              "name": "is_enabled",
              "docstring": "Check if caching is enabled.",
              "signature": "(self) -> bool"
            },
            {
              "name": "set",
              "docstring": "Cache LLM response with metadata.",
              "signature": "(self, messages: List[Dict[str, str]], response: str, **kwargs) -> None"
            }
          ],
          "init_signature": "(self, max_size: int = 1000, ttl_seconds: int = 3600, enable_stats: bool = True)"
        },
        {
          "name": "Mistral",
          "docstring": "Base class for all LLM implementations in the cogency framework.\n\nAll LLM providers support:\n- Streaming execution for real-time output\n- Automatic key rotation for high-volume usage\n- Rate limiting via yield_interval parameter\n- Unified interface across providers\n- Dynamic model/parameter configuration",
          "module": "cogency.services.llm.mistral",
          "methods": [
            {
              "name": "next_key",
              "docstring": "Get next API key - rotates automatically on every call.",
              "signature": "(self) -> str"
            },
            {
              "name": "run",
              "docstring": "Generate a response from the LLM given a list of messages.\n\nArgs:\n    messages: List of message dictionaries with 'role' and 'content' keys\n    **kwargs: Additional parameters for the LLM call\n\nReturns:\n    Result containing string response from the LLM or error",
              "signature": "(self, messages: List[Dict[str, str]], **kwargs) -> resilient_result.result.Result"
            },
            {
              "name": "stream",
              "docstring": "Generate a streaming response from the LLM given a list of messages.\n\nArgs:\n    messages: List of message dictionaries with 'role' and 'content' keys\n    yield_interval: Minimum time between yields for rate limiting (seconds)\n    **kwargs: Additional parameters for the LLM call\n\nReturns:\n    AsyncIterator[str] for streaming response",
              "signature": "(self, messages: List[Dict[str, str]], **kwargs) -> AsyncIterator[str]"
            }
          ],
          "init_signature": "(self, **kwargs)"
        },
        {
          "name": "MistralEmbed",
          "docstring": "Mistral embedding provider with key rotation.",
          "module": "cogency.services.embed.mistral",
          "methods": [
            {
              "name": "embed",
              "docstring": "Embed text(s) - handles both single strings and lists.",
              "signature": "(self, text: str | list[str], **kwargs) -> resilient_result.result.Result"
            },
            {
              "name": "embed_array",
              "docstring": "Embed texts and return as 2D numpy array",
              "signature": "(self, texts: list[str], **kwargs) -> resilient_result.result.Result"
            },
            {
              "name": "embed_text",
              "docstring": "Embed single text - convenience method for memory stores",
              "signature": "(self, text: str, **kwargs) -> resilient_result.result.Result"
            }
          ],
          "init_signature": "(self, api_keys: Union[str, list[str]] = None, model: str = 'mistral-embed', **kwargs)"
        },
        {
          "name": "Nomic",
          "docstring": "Nomic embedding provider with key rotation.",
          "module": "cogency.services.embed.nomic",
          "methods": [
            {
              "name": "embed",
              "docstring": "Embed text(s) - handles both single strings and lists.",
              "signature": "(self, text: str | list[str], batch_size: Optional[int] = None, **kwargs) -> resilient_result.result.Result"
            },
            {
              "name": "embed_array",
              "docstring": "Embed texts and return as 2D numpy array",
              "signature": "(self, texts: list[str], **kwargs) -> resilient_result.result.Result"
            },
            {
              "name": "embed_text",
              "docstring": "Embed single text - convenience method for memory stores",
              "signature": "(self, text: str, **kwargs) -> resilient_result.result.Result"
            },
            {
              "name": "set_model",
              "docstring": "Set the embedding model and dimensionality\n\nArgs:\n    model: Model name (e.g., 'nomic-embed-text-v2')\n    dims: Embedding dimensions",
              "signature": "(self, model: str, dims: int = 768)"
            }
          ],
          "init_signature": "(self, api_keys: Union[str, list[str]] = None, **kwargs)"
        },
        {
          "name": "OpenAI",
          "docstring": "Base class for all LLM implementations in the cogency framework.\n\nAll LLM providers support:\n- Streaming execution for real-time output\n- Automatic key rotation for high-volume usage\n- Rate limiting via yield_interval parameter\n- Unified interface across providers\n- Dynamic model/parameter configuration",
          "module": "cogency.services.llm.openai",
          "methods": [
            {
              "name": "next_key",
              "docstring": "Get next API key - rotates automatically on every call.",
              "signature": "(self) -> str"
            },
            {
              "name": "run",
              "docstring": "Generate a response from the LLM given a list of messages.\n\nArgs:\n    messages: List of message dictionaries with 'role' and 'content' keys\n    **kwargs: Additional parameters for the LLM call\n\nReturns:\n    Result containing string response from the LLM or error",
              "signature": "(self, messages: List[Dict[str, str]], **kwargs) -> resilient_result.result.Result"
            },
            {
              "name": "stream",
              "docstring": "Generate a streaming response from the LLM given a list of messages.\n\nArgs:\n    messages: List of message dictionaries with 'role' and 'content' keys\n    yield_interval: Minimum time between yields for rate limiting (seconds)\n    **kwargs: Additional parameters for the LLM call\n\nReturns:\n    AsyncIterator[str] for streaming response",
              "signature": "(self, messages: List[Dict[str, str]], **kwargs) -> AsyncIterator[str]"
            }
          ],
          "init_signature": "(self, **kwargs)"
        },
        {
          "name": "OpenAIEmbed",
          "docstring": "OpenAI embedding provider with key rotation.",
          "module": "cogency.services.embed.openai",
          "methods": [
            {
              "name": "embed",
              "docstring": "Embed text(s) - handles both single strings and lists.",
              "signature": "(self, text: str | list[str], **kwargs) -> resilient_result.result.Result"
            },
            {
              "name": "embed_array",
              "docstring": "Embed texts and return as 2D numpy array",
              "signature": "(self, texts: list[str], **kwargs) -> resilient_result.result.Result"
            },
            {
              "name": "embed_text",
              "docstring": "Embed single text - convenience method for memory stores",
              "signature": "(self, text: str, **kwargs) -> resilient_result.result.Result"
            }
          ],
          "init_signature": "(self, api_keys: Union[str, list[str]] = None, model: str = 'text-embedding-3-small', **kwargs)"
        },
        {
          "name": "Provider",
          "docstring": "Manages providers with auto-detection, singletons, and lazy initialization.",
          "module": "cogency.utils.providers",
          "methods": [
            {
              "name": "all_classes",
              "docstring": "Get all provider classes for export.",
              "signature": "(self) -> Dict[str, Type[~T]]"
            },
            {
              "name": "get",
              "docstring": "Get provider class (not instance).",
              "signature": "(self, provider: Optional[str] = None) -> Type[~T]"
            },
            {
              "name": "instance",
              "docstring": "Get singleton instance of provider.",
              "signature": "(self, provider: Optional[str] = None, **kwargs) -> ~T"
            }
          ],
          "init_signature": "(self, providers: Dict[str, Type[~T]], detect_fn: Optional[Callable[[], str]] = None, default: Optional[str] = None)"
        },
        {
          "name": "Sentence",
          "docstring": "Sentence Transformers embedding provider - local, no API keys needed.",
          "module": "cogency.services.embed.sentence",
          "methods": [
            {
              "name": "embed",
              "docstring": "Embed text(s) - handles both single strings and lists.",
              "signature": "(self, text: str | list[str], **kwargs) -> resilient_result.result.Result"
            },
            {
              "name": "embed_array",
              "docstring": "Embed texts and return as 2D numpy array",
              "signature": "(self, texts: list[str], **kwargs) -> resilient_result.result.Result"
            },
            {
              "name": "embed_text",
              "docstring": "Embed single text - convenience method for memory stores",
              "signature": "(self, text: str, **kwargs) -> resilient_result.result.Result"
            }
          ],
          "init_signature": "(self, model: str = 'all-MiniLM-L6-v2', **kwargs)"
        },
        {
          "name": "xAI",
          "docstring": "Base class for all LLM implementations in the cogency framework.\n\nAll LLM providers support:\n- Streaming execution for real-time output\n- Automatic key rotation for high-volume usage\n- Rate limiting via yield_interval parameter\n- Unified interface across providers\n- Dynamic model/parameter configuration",
          "module": "cogency.services.llm.xai",
          "methods": [
            {
              "name": "next_key",
              "docstring": "Get next API key - rotates automatically on every call.",
              "signature": "(self) -> str"
            },
            {
              "name": "run",
              "docstring": "Generate a response from the LLM given a list of messages.\n\nArgs:\n    messages: List of message dictionaries with 'role' and 'content' keys\n    **kwargs: Additional parameters for the LLM call\n\nReturns:\n    Result containing string response from the LLM or error",
              "signature": "(self, messages: List[Dict[str, str]], **kwargs) -> resilient_result.result.Result"
            },
            {
              "name": "stream",
              "docstring": "Generate a streaming response from the LLM given a list of messages.\n\nArgs:\n    messages: List of message dictionaries with 'role' and 'content' keys\n    yield_interval: Minimum time between yields for rate limiting (seconds)\n    **kwargs: Additional parameters for the LLM call\n\nReturns:\n    AsyncIterator[str] for streaming response",
              "signature": "(self, messages: List[Dict[str, str]], **kwargs) -> AsyncIterator[str]"
            }
          ],
          "init_signature": "(self, **kwargs)"
        }
      ],
      "functions": [
        {
          "name": "detect_provider",
          "docstring": "Generic provider detection based on available API keys.\n\nArgs:\n    providers: Dict mapping provider names to their env key prefixes\n              e.g. {\"openai\": \"OPENAI\", \"anthropic\": \"ANTHROPIC\"}\n    fallback: Default provider if no keys detected\n\nReturns:\n    Provider name with available keys, or fallback",
          "module": "cogency.utils.detection",
          "signature": "(providers: Dict[str, str], fallback: Optional[str] = None) -> str"
        },
        {
          "name": "setup_embed",
          "docstring": "Get embed provider class with automagical discovery.",
          "module": "cogency.services",
          "signature": "(provider: Optional[str] = None) -> Type[cogency.services.embed.base.Embed]"
        },
        {
          "name": "setup_llm",
          "docstring": "Get LLM provider class or instance with automagical discovery.",
          "module": "cogency.services",
          "signature": "(provider: Union[str, cogency.services.llm.base.LLM, NoneType] = None) -> cogency.services.llm.base.LLM"
        }
      ]
    },
    "utils": {
      "name": "utils",
      "docstring": "Shared utilities for robust LLM response handling.",
      "classes": [
        {
          "name": "KeyManager",
          "docstring": "Unified key management - auto-detects, handles rotation, eliminates provider DRY.",
          "module": "cogency.utils.keys",
          "methods": [
            {
              "name": "get_current",
              "docstring": "Get the current active key.",
              "signature": "(self) -> str"
            },
            {
              "name": "get_next",
              "docstring": "Get next key in rotation - advances every call.",
              "signature": "(self) -> str"
            },
            {
              "name": "has_multiple",
              "docstring": "Check if we have multiple keys available for rotation.",
              "signature": "(self) -> bool"
            },
            {
              "name": "rotate_key",
              "docstring": "Rotate to next key if rotator exists. Returns feedback message.",
              "signature": "(self) -> Optional[str]"
            }
          ],
          "init_signature": "(self, api_key: Optional[str] = None, key_rotator: Optional[cogency.utils.keys.KeyRotator] = None)"
        },
        {
          "name": "KeyRotator",
          "docstring": "Simple key rotator for API rate limit avoidance.",
          "module": "cogency.utils.keys",
          "methods": [
            {
              "name": "get_current_key",
              "docstring": "Get current key without advancing.",
              "signature": "(self) -> str"
            },
            {
              "name": "get_next_key",
              "docstring": "Get next key in rotation - advances every call.",
              "signature": "(self) -> str"
            },
            {
              "name": "rotate_key",
              "docstring": "Rotate to next key immediately. Returns feedback.",
              "signature": "(self) -> str"
            }
          ],
          "init_signature": "(self, keys: List[str])"
        },
        {
          "name": "Provider",
          "docstring": "Manages providers with auto-detection, singletons, and lazy initialization.",
          "module": "cogency.utils.providers",
          "methods": [
            {
              "name": "all_classes",
              "docstring": "Get all provider classes for export.",
              "signature": "(self) -> Dict[str, Type[~T]]"
            },
            {
              "name": "get",
              "docstring": "Get provider class (not instance).",
              "signature": "(self, provider: Optional[str] = None) -> Type[~T]"
            },
            {
              "name": "instance",
              "docstring": "Get singleton instance of provider.",
              "signature": "(self, provider: Optional[str] = None, **kwargs) -> ~T"
            }
          ],
          "init_signature": "(self, providers: Dict[str, Type[~T]], detect_fn: Optional[Callable[[], str]] = None, default: Optional[str] = None)"
        }
      ],
      "functions": [
        {
          "name": "detect_provider",
          "docstring": "Generic provider detection based on available API keys.\n\nArgs:\n    providers: Dict mapping provider names to their env key prefixes\n              e.g. {\"openai\": \"OPENAI\", \"anthropic\": \"ANTHROPIC\"}\n    fallback: Default provider if no keys detected\n\nReturns:\n    Provider name with available keys, or fallback",
          "module": "cogency.utils.detection",
          "signature": "(providers: Dict[str, str], fallback: Optional[str] = None) -> str"
        },
        {
          "name": "format_tool_error",
          "docstring": "Format tool errors for users.",
          "module": "cogency.utils.formatting",
          "signature": "(tool_name: str, error: Exception) -> str"
        },
        {
          "name": "format_tool_params",
          "docstring": "Format tool parameters for concise display in logs",
          "module": "cogency.utils.formatting",
          "signature": "(params: Dict[str, Any]) -> str"
        },
        {
          "name": "interactive_mode",
          "docstring": "Interactive mode with magical DX.",
          "module": "cogency.utils.cli",
          "signature": "(agent) -> None"
        },
        {
          "name": "is_simple_query",
          "docstring": "Check if query is simple enough to suggest fast mode.\n\nStructural heuristic: Single/double word queries without complex punctuation\nlikely don't need deep reasoning cycles.",
          "module": "cogency.utils.heuristics",
          "signature": "(query: str) -> bool"
        },
        {
          "name": "main",
          "docstring": "Magical CLI entry point.",
          "module": "cogency.utils.cli",
          "signature": "()"
        },
        {
          "name": "normalize_reasoning",
          "docstring": "Normalizes the 'reasoning' field into a list of strings.",
          "module": "cogency.utils.parsing",
          "signature": "(val: Any) -> List[str]"
        },
        {
          "name": "parse_json",
          "docstring": "Extract JSON from LLM response - clean Result pattern.\n\nHandles:\n- Markdown code fences (```json and ```)\n- Proper brace matching for JSON objects\n- Regex-based pattern extraction for common failure modes\n- Graceful Result.fail() on errors\n\nArgs:\n    response: Raw LLM response string\n\nReturns:\n    Result.ok(data) or Result.fail(error)",
          "module": "cogency.utils.parsing",
          "signature": "(response: str, trace_fn: Optional[Callable[[str], NoneType]] = None) -> resilient_result.result.Result"
        },
        {
          "name": "parse_json_with_correction",
          "docstring": "Parse JSON with self-correction loop for malformed responses.",
          "module": "cogency.utils.parsing",
          "signature": "(response: str, llm_fn: Optional[Callable] = None, trace_fn: Optional[Callable[[str], NoneType]] = None, max_attempts: int = 2) -> resilient_result.result.Result"
        },
        {
          "name": "parse_tool_calls",
          "docstring": "Extract tool calls from parsed JSON. Return None if no tool calls.",
          "module": "cogency.utils.parsing",
          "signature": "(json_data: Dict[str, Any]) -> Optional[List[Dict[str, Any]]]"
        },
        {
          "name": "summarize_result",
          "docstring": "Extract key information from tool results for compact display",
          "module": "cogency.utils.formatting",
          "signature": "(result: Any) -> str"
        },
        {
          "name": "trace_args",
          "docstring": "Parse trace argument from CLI and return trace flag.",
          "module": "cogency.utils.cli",
          "signature": "() -> bool"
        },
        {
          "name": "truncate",
          "docstring": "Intelligently truncate text while preserving context for URLs and paths",
          "module": "cogency.utils.formatting",
          "signature": "(text: str, max_len: int = 30) -> str"
        },
        {
          "name": "validate_query",
          "docstring": "Validate query input, return error message if invalid.",
          "module": "cogency.utils.validation",
          "signature": "(query: str) -> str | None"
        }
      ]
    },
    "types": {
      "name": "types",
      "docstring": "Type definitions - core data structures for agent execution and communication.",
      "classes": [
        {
          "name": "Preprocessed",
          "docstring": "Preprocessed(memory: Optional[str] = None, tags: List[str] = <factory>, memory_type: Optional[str] = None, mode: Optional[str] = None, selected_tools: List[str] = <factory>, reasoning: Optional[str] = None)",
          "module": "cogency.types.preprocessed",
          "methods": [],
          "init_signature": "(self, memory: Optional[str] = None, tags: List[str] = <factory>, memory_type: Optional[str] = None, mode: Optional[str] = None, selected_tools: List[str] = <factory>, reasoning: Optional[str] = None) -> None"
        },
        {
          "name": "Reasoning",
          "docstring": "Reasoning(thinking: Optional[str] = None, tool_calls: List[cogency.types.tools.ToolCall] = <factory>, switch_to: Optional[str] = None, reasoning: List[str] = <factory>, reflect: Optional[str] = None, plan: Optional[str] = None, workspace_update: Optional[Dict[str, str]] = None)",
          "module": "cogency.types.reasoning",
          "methods": [],
          "init_signature": "(self, thinking: Optional[str] = None, tool_calls: List[cogency.types.tools.ToolCall] = <factory>, switch_to: Optional[str] = None, reasoning: List[str] = <factory>, reflect: Optional[str] = None, plan: Optional[str] = None, workspace_update: Optional[Dict[str, str]] = None) -> None"
        },
        {
          "name": "Response",
          "docstring": "Response(text: Optional[str] = None, tool_calls: List[Dict[str, Any]] = <factory>)",
          "module": "cogency.types.response",
          "methods": [],
          "init_signature": "(self, text: Optional[str] = None, tool_calls: List[Dict[str, Any]] = <factory>) -> None"
        },
        {
          "name": "ToolCall",
          "docstring": "Clean tool call structure for reasoning phase.",
          "module": "cogency.types.tools",
          "methods": [
            {
              "name": "to_dict",
              "docstring": "Convert to dict for storage.",
              "signature": "(self) -> Dict[str, Any]"
            }
          ],
          "init_signature": "(self, name: str, args: Dict[str, Any], result: Optional[str] = None, outcome: Optional[cogency.types.tools.ToolOutcome] = None) -> None"
        },
        {
          "name": "ToolOutcome",
          "docstring": "Standardized tool execution results.",
          "module": "cogency.types.tools",
          "methods": [],
          "init_signature": "(self, *args, **kwds)"
        },
        {
          "name": "ToolResult",
          "docstring": "Beautiful property wrapper for tool execution results.",
          "module": "cogency.types.tools",
          "methods": [],
          "init_signature": "(self, data: Dict[str, Any])"
        }
      ],
      "functions": [
        {
          "name": "validate",
          "docstring": "Validate and convert dict parameters to dataclass instance.\n\nArgs:\n    params: Raw parameters from tool call\n    params_class: Dataclass type to validate against\n\nReturns:\n    Validated dataclass instance\n\nRaises:\n    ValueError: If validation fails",
          "module": "cogency.types.params",
          "signature": "(params: Dict[str, Any], params_class: Type[~T]) -> ~T"
        }
      ]
    },
    "phases": {
      "name": "phases",
      "docstring": "Clean phase imports - zero ceremony.",
      "classes": [
        {
          "name": "Act",
          "docstring": "Self-routing cognitive phase.",
          "module": "cogency.phases.act",
          "methods": [
            {
              "name": "next_phase",
              "docstring": "Default: end flow.",
              "signature": "(self, state: cogency.state.State) -> str"
            }
          ],
          "init_signature": "(self, tools)"
        },
        {
          "name": "Phase",
          "docstring": "Self-routing cognitive phase.",
          "module": "cogency.phases.base",
          "methods": [
            {
              "name": "next_phase",
              "docstring": "Default: end flow.",
              "signature": "(self, state: cogency.state.State) -> str"
            }
          ],
          "init_signature": "(self, func: Any, **kwargs)"
        },
        {
          "name": "Preprocess",
          "docstring": "Self-routing cognitive phase.",
          "module": "cogency.phases.preprocess",
          "methods": [
            {
              "name": "next_phase",
              "docstring": "Default: end flow.",
              "signature": "(self, state: cogency.state.State) -> str"
            }
          ],
          "init_signature": "(self, llm, tools, memory, identity=None)"
        },
        {
          "name": "Reason",
          "docstring": "Self-routing cognitive phase.",
          "module": "cogency.phases.reason",
          "methods": [
            {
              "name": "next_phase",
              "docstring": "Default: end flow.",
              "signature": "(self, state: cogency.state.State) -> str"
            }
          ],
          "init_signature": "(self, llm, tools, identity=None)"
        },
        {
          "name": "Respond",
          "docstring": "Self-routing cognitive phase.",
          "module": "cogency.phases.respond",
          "methods": [
            {
              "name": "next_phase",
              "docstring": "Default: end flow.",
              "signature": "(self, state: cogency.state.State) -> str"
            }
          ],
          "init_signature": "(self, llm, tools, identity=None, output_schema=None)"
        }
      ],
      "functions": [
        {
          "name": "parse_switch",
          "docstring": "Extract mode switching directives from LLM JSON response",
          "module": "cogency.phases.reasoning.switching",
          "signature": "(llm_response: str) -> Tuple[Optional[str], Optional[str]]"
        },
        {
          "name": "prompt_reasoning",
          "docstring": "Generate unified prompt with mode-specific sections injected.",
          "module": "cogency.phases.reasoning.prompt",
          "signature": "(mode: str, tool_registry: str, query: str, context: str, iteration: int = 0, depth: int = 5, state=None) -> str"
        },
        {
          "name": "setup_phases",
          "docstring": "Zero ceremony phase creation.",
          "module": "cogency.phases",
          "signature": "(llm, tools, memory, identity, output_schema)"
        },
        {
          "name": "should_switch",
          "docstring": "Determine if mode switch should occur based on request and iteration context",
          "module": "cogency.phases.reasoning.switching",
          "signature": "(current_mode: str, switch_to: Optional[str], switch_why: Optional[str], iteration: int = 0, depth: int = 5) -> bool"
        },
        {
          "name": "switch_mode",
          "docstring": "Switch reasoning mode - only changes mode, keeps all context",
          "module": "cogency.phases.reasoning.switching",
          "signature": "(state: Dict[str, Any], new_mode: str, switch_why: str) -> Dict[str, Any]"
        }
      ]
    }
  }
}